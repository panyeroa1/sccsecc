<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Translate Overlay (Sequential TTS)</title>
  <style>
    :root{
      /* Dark Background */
      --bg: rgba(0,0,0,.92);

      /* LimeGreen Theme */
      --txt: #32cd32;
      --stroke: rgba(50, 205, 50, .3);
      --stroke2: rgba(50, 205, 50, .2);
      --muted: rgba(50, 205, 50, .7);
      --pill: rgba(0, 20, 0, .6);
      --shadow: 0 14px 40px rgba(0,0,0,.6);

      --radius: 8px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --orb-size: 75px;

      /* Layering */
      --orbit-z: 100000;
    }

    *{ box-sizing:border-box; }
    html, body{
      height: 100%;
    }
    body{
      margin:0;
      background:#050505;
      color:var(--txt);
      font-family: var(--mono);
      height: 100%;
      min-height: 100vh;
      overflow:hidden;
    }

    /* =========================================================
       ✅ ROOT CONTAINER (Fix: host containment for overlay/sidebar/orb)
       - Root covers the viewport OR the host container (when embedded)
       - Root itself doesn't block clicks except on UI elements
    ========================================================= */
    .orbitRoot{
      position: fixed;
      inset: 0;
      z-index: var(--orbit-z);
      pointer-events: none;
    }
    .orbitRoot.in-host-root{
      position: absolute;
      inset: 0;
    }
    body.embedded .orbitRoot{
      position: absolute;
      inset: 0;
    }

    /* Allow interaction only on actual UI elements */
    .orbitRoot .overlay,
    .orbitRoot .sidebar,
    .orbitRoot .orb{
      pointer-events: auto;
    }

    .overlay{
      position:absolute; /* ✅ was fixed; now contained in root/host */
      left:12px;
      right:12px;
      top:12px;
      margin:auto;
      max-width: 980px;
      background: var(--bg);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      -webkit-backdrop-filter: blur(6px);
      backdrop-filter: blur(6px);
      transition: height 0.3s ease;
    }

    body.embedded .overlay{
      position: absolute;
      inset: 0;
      height: 100%;
      margin: 0;
      max-width: none;
      border-radius: 0;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:8px 10px 4px 10px;
      gap:8px;
    }

    .leftGroup{
      display:flex;
      align-items:center;
      gap:6px;
      min-width: 0;
      flex: 1;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      border: 1px solid var(--stroke);
      border-radius: 99px;
      background: var(--pill);
      color: var(--txt);
      font-size: 12px;
      line-height: 1;
      white-space: nowrap;
    }

    .pill button,
    .pill select{
      all: unset;
      cursor: pointer;
      color: var(--txt);
      font-size: 12px;
      line-height: 1;
    }

    .pill select{
      padding-right: 12px;
      position:relative;
    }

    .arrow{
      opacity:.8;
      font-size:12px;
      padding:0 2px;
      -webkit-user-select:none;
      user-select:none;
    }

    .rightGroup{
      display:flex;
      align-items:center;
      gap:6px;
      flex: 0 0 auto;
    }

    .iconBtn{
      width:28px;
      height:28px;
      border-radius:6px;
      border: 1px solid var(--stroke2);
      background: rgba(50,205,50,.05);
      color: var(--txt);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }

    .iconBtn:hover{ background: rgba(50,205,50,.15); }

    .content{
      padding: 6px 12px 10px 12px;
    }

    /* ✅ TRANSLATED TEXT STYLE */
    .bigText{
      font-size: 14px;          /* requested 14px */
      color: #ffffff;           /* requested white */
      line-height: 1.3;
      letter-spacing: 0.1px;
      word-break: break-word;
      text-shadow: 0 0 5px rgba(50, 205, 50, 0.2);
    }

    .subline{
      margin-top:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color: var(--muted);
      font-size: 11px;
      border-top: 1px solid var(--stroke2);
      padding-top:8px;
    }

    .statusDot{
      width:8px;
      height:8px;
      border-radius:999px;
      background: rgba(50,205,50,.3);
      box-shadow: 0 0 0 1px rgba(50,205,50,.2) inset;
    }

    .statusDot.on{
      background: #32cd32;
      box-shadow: 0 0 0 2px rgba(50,205,50,.3) inset, 0 0 12px rgba(50,205,50,.5);
    }

    .statusDot.err{
      background: #ff4d4d;
      box-shadow: 0 0 0 2px rgba(255,77,77,.22) inset, 0 0 18px rgba(255,77,77,.20);
    }

    .chevronWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0 0 6px 0;
    }

    .chevronBtn{
      width:36px;
      height:22px;
      border-radius: 99px;
      border: 1px solid var(--stroke2);
      background: rgba(50,205,50,.05);
      color: var(--muted);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      font-size: 10px;
      -webkit-user-select:none;
      user-select:none;
    }

    .collapsed .content{ display:none; }
    .collapsed .chevronBtn{ transform: rotate(180deg); }

    /* ✅ Sidebar contained in root/host (was fixed) */
    .sidebar{
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      z-index: calc(var(--orbit-z) + 2);
    }

    .sidebarBtn{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      width:56px;
      padding:10px 8px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: var(--pill);
      color: var(--txt);
      cursor:pointer;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
    }

    .sidebarBtn:hover{ background: rgba(50,205,50,.18); }

    .sidebarIcon{
      width:24px;
      height:24px;
    }

    /* ✅ Orb contained in root/host (was fixed) */
    .orb{
      position: absolute;
      right: 22px;
      bottom: 22px;
      width: var(--orb-size);
      height: var(--orb-size);
      border-radius: 999px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: grab;
      z-index: calc(var(--orbit-z) + 3);
      -webkit-user-select:none;
      user-select:none;
      touch-action: none;
      outline: none;
    }

    .orb.dragging{ cursor: grabbing; }

    .orbCore{
      width: 100%;
      height: 100%;
      border-radius: 999px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.25), rgba(0,0,0,0) 45%),
        radial-gradient(circle at 70% 70%, rgba(50,205,50,.18), rgba(0,0,0,0) 50%),
        linear-gradient(135deg, rgba(26,40,26,.8), rgba(6,14,6,.95));
      border: 1px solid var(--stroke);
      box-shadow:
        0 8px 26px rgba(0,0,0,.5),
        0 0 22px rgba(50,205,50,.25) inset,
        0 0 16px rgba(50,205,50,.2);
      animation: orbPulse 3s ease-in-out infinite;
    }

    .orbViz{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:4px;
      pointer-events:none;
    }

    .orbVizRow{
      display:flex;
      align-items:flex-end;
      gap:3px;
      height:12px;
    }

    .orbVizRow[data-viz="in"] .orbBar{
      background: rgba(50,205,50,.85);
    }

    .orbVizRow[data-viz="out"] .orbBar{
      background: rgba(255,255,255,.75);
    }

    .orbBar{
      width:3px;
      height:4px;
      border-radius: 2px;
      box-shadow: 0 0 8px rgba(50,205,50,.2);
      transition: height 0.08s ease-out;
    }

    @keyframes orbPulse{
      0%,100%{ transform: scale(1); }
      50%{ transform: scale(1.03); }
    }

    @media (max-width: 720px){
      .overlay{
        left:8px;
        right:8px;
        top:8px;
        max-width: none;
      }

      .topbar{
        flex-direction:column;
        align-items:flex-start;
        gap:6px;
      }

      .leftGroup{
        flex-wrap:wrap;
        gap:6px;
      }

      .rightGroup{
        align-self:flex-end;
      }

      .pill{
        font-size: 11px;
        padding:4px 6px;
      }

      .content{
        padding: 6px 10px 10px 10px;
      }

      .bigText{
        font-size: 13px;
      }

      .sidebar{
        left:8px;
        top:auto;
        bottom:96px;
        transform:none;
      }

      .sidebarBtn{
        width:52px;
        padding:8px 6px;
      }

      .orb{
        right:14px;
        bottom:14px;
        transform: scale(0.92);
      }
    }
  </style>
</head>

<body>

<audio id="tts" autoplay></audio>

<!-- ✅ Root container so overlay + sidebar + orb are always inside host viewport when embedded -->
<div id="orbitRoot" class="orbitRoot">

  <div class="sidebar">
    <button id="orbitSidebarBtn" class="sidebarBtn" type="button" title="Orbit Translator" aria-label="Orbit Translator">
      <svg class="sidebarIcon" viewBox="0 0 48 48" fill="none" aria-hidden="true">
        <circle cx="20" cy="24" r="10" stroke="currentColor" stroke-width="2" />
        <path d="M6 28c7-6 21-9 36-5" stroke="currentColor" stroke-width="2" opacity="0.7" />
        <circle cx="36" cy="14" r="3" fill="currentColor" opacity="0.7" />
      </svg>
      <span>Orbit</span>
    </button>
  </div>

  <div id="overlay" class="overlay">
    <div class="topbar">
      <div class="leftGroup">
        <div class="pill">
          <button id="toggleListenBtn" type="button" style="display:inline-flex;align-items:center;gap:8px;">
            <span style="display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none">
                <path d="M4 5h7m-7 4h5m7-4h4m-4 0v14m0-14l-4 4m4-4l4 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity="0.92"/>
                <path d="M5 19h6m-6 0v-4m0 4l4-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity="0.92"/>
              </svg>
            </span>
            <span id="translatingLabel">Translating</span>
          </button>
        </div>

        <div class="pill">
          <select id="srcLang" aria-label="Source language" title="Source language"></select>
        </div>

        <div class="arrow">→</div>

        <div class="pill">
          <select id="tgtLang" aria-label="Target language" title="Target language"></select>
          <span style="opacity:.75;font-size:10px;">▾</span>
        </div>
      </div>

      <div class="rightGroup">
        <button id="fsBtn" class="iconBtn" type="button" title="Fullscreen">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none">
            <path d="M9 4H4v5M15 4h5v5M9 20H4v-5M15 20h5v-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" opacity="0.92"/>
          </svg>
        </button>
        <button id="closeBtn" class="iconBtn" type="button" title="Close">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none">
            <path d="M6 6l12 12M18 6L6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" opacity="0.92"/>
          </svg>
        </button>
      </div>
    </div>

    <div class="content">
      <div id="bigText" class="bigText">Tap “Translating” to start listening…</div>

      <div class="subline">
        <div style="display:flex;align-items:center;gap:8px;">
          <span id="dot" class="statusDot"></span>
          <span id="status">Idle</span>
        </div>
        <div id="debug" style="opacity:.85;text-align:right;max-width:55%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></div>
      </div>
    </div>

    <div class="chevronWrap">
      <button id="chevBtn" class="chevronBtn" type="button">⌄</button>
    </div>
  </div>

  <!-- ✅ Orb added (Fix: orb markup was missing; visualizer bars now exist) -->
  <div id="orb" class="orb" tabindex="0" role="button" aria-label="Toggle overlay">
    <div class="orbCore" aria-hidden="true"></div>
    <div class="orbViz" aria-hidden="true">
      <div class="orbVizRow" data-viz="in">
        <span class="orbBar"></span><span class="orbBar"></span><span class="orbBar"></span><span class="orbBar"></span>
        <span class="orbBar"></span><span class="orbBar"></span><span class="orbBar"></span>
      </div>
      <div class="orbVizRow" data-viz="out">
        <span class="orbBar"></span><span class="orbBar"></span><span class="orbBar"></span><span class="orbBar"></span>
        <span class="orbBar"></span><span class="orbBar"></span><span class="orbBar"></span>
      </div>
    </div>
  </div>

</div><!-- /orbitRoot -->

<script>
/* =========================================================
   1. Host Embedding (UPDATED: move orbitRoot, not just overlay)
========================================================= */
(() => {
  const host = document.querySelector("[data-translate-overlay-host]");
  const root = document.getElementById("orbitRoot");

  if (host && root) {
    const cs = getComputedStyle(host);
    if (cs.position === "static") host.style.position = "relative";
    host.appendChild(root);
    root.classList.add("in-host-root");
  }

  let embedded = false;
  try {
    embedded = window.self !== window.top;
  } catch (_) {
    embedded = true;
  }

  if (!host && embedded) {
    document.body.classList.add("embedded");
  }
})();

/* =========================================================
   2. Orbit AI TTS Engine (Queue System)
========================================================= */
const ORBIT_TTS_CFG = {
  endpoint: "/api/tts",
  provider: "cartesia"
};

// Sonic-3 supported language codes (42)
const CARTESIA_LANGS = new Set([
  "en","fr","de","es","pt","zh","ja","hi","it","ko","nl","pl","ru","sv","tr","tl",
  "bg","ro","ar","cs","el","fi","hr","ms","sk","da","ta","uk","hu","no","vi","bn",
  "th","he","ka","id","te","gu","kn","ml","mr","pa"
]);

const ttsAudio = document.getElementById("tts");
let ttsQueue = [];
let ttsBusy = false;

/* =========================================================
   ✅ ORIGINAL AUDIO DUCKING (20%) DURING TTS
========================================================= */
const DUCK_TARGET = 0.20;
const DUCK_FADE_MS = 120;
const RESTORE_FADE_MS = 160;
let duckRefCount = 0;
const duckStore = new Map(); // el -> { vol, muted }
const duckAnim = new Map(); // el -> rAF id

function listOtherMediaEls() {
  const all = Array.from(document.querySelectorAll("audio,video"));
  return all.filter(el => el && el !== ttsAudio);
}

function rampVolume(el, to, duration) {
  if (!el || typeof el.volume !== "number") return;
  const from = el.volume;
  const target = Math.max(0, Math.min(1, to));
  if (duckAnim.has(el)) {
    cancelAnimationFrame(duckAnim.get(el));
    duckAnim.delete(el);
  }
  if (!isFinite(from) || duration <= 0 || Math.abs(from - target) < 0.001) {
    el.volume = target;
    return;
  }
  const start = performance.now();
  const tick = (now) => {
    const t = Math.min(1, (now - start) / duration);
    const eased = t * (2 - t); // ease-out
    try {
      el.volume = from + (target - from) * eased;
    } catch (_) {}
    if (t < 1) {
      duckAnim.set(el, requestAnimationFrame(tick));
    } else {
      duckAnim.delete(el);
    }
  };
  duckAnim.set(el, requestAnimationFrame(tick));
}

function duckOtherMedia() {
  duckRefCount++;
  if (duckRefCount > 1) return;

  const els = listOtherMediaEls();
  for (const el of els) {
    try {
      if (!duckStore.has(el)) {
        duckStore.set(el, {
          vol: (typeof el.volume === "number") ? el.volume : 1,
          muted: !!el.muted
        });
      }
      if (!el.muted) {
        const target = Math.min(DUCK_TARGET, (typeof el.volume === "number") ? el.volume : 1);
        rampVolume(el, target, DUCK_FADE_MS);
      }
    } catch (_) {}
  }
}

function restoreOtherMedia() {
  duckRefCount = Math.max(0, duckRefCount - 1);
  if (duckRefCount !== 0) return;

  for (const [el, st] of duckStore.entries()) {
    try {
      el.muted = st.muted;
      if (!el.muted && typeof st.vol === "number") {
        rampVolume(el, st.vol, RESTORE_FADE_MS);
      }
    } catch (_) {}
  }
  duckStore.clear();
}

function forceRestoreOtherMedia() {
  // Ensures we always restore after a forced stop
  duckRefCount = 1;
  restoreOtherMedia();
}

/* =========================================================
   ✅ Object URL lifecycle (Fix: prevent memory leak)
========================================================= */
let currentTtsObjectUrl = null;
function revokeCurrentTtsUrl() {
  if (currentTtsObjectUrl) {
    try { URL.revokeObjectURL(currentTtsObjectUrl); } catch(_) {}
    currentTtsObjectUrl = null;
  }
}

/* =========================================================
   Mobile Audio Unlock
========================================================= */
async function unlockAudioOnce() {
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    if (AC) {
      const ctx = new AC();
      await ctx.resume();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      gain.gain.value = 0.0001;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.1);
    }
    startBackgroundLoop();
  } catch (_) {}
}

let bgInterval = null;
function startBackgroundLoop() {
  if (bgInterval) return;
  bgInterval = setInterval(async () => {
    if (!listening && ttsQueue.length === 0) return;
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) {
        const ctx = new AC();
        await ctx.resume();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        gain.gain.value = 0.00001;
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.01);
      }
    } catch(e) {}
  }, 15000);
}

function normalizeSpaces(s) {
  return (s || "").replace(/\s+/g, " ").trim();
}

// Split long text
function splitSpeakSegments(text) {
  const t = normalizeSpaces(text);
  if (!t) return [];
  const parts = t.match(/[^.!?…]+[.!?…]*/g) || [t];
  const out = [];
  for (const p of parts.map(s => s.trim()).filter(Boolean)) {
    if (p.length <= 180) out.push(p);
    else for (let i=0;i<p.length;i+=180) out.push(p.slice(i,i+180));
  }
  return out;
}

// Add to Queue
function enqueueTTS(text, ttsLangCode) {
  const segs = splitSpeakSegments(text);
  if (!segs.length) return;
  for (const s of segs) ttsQueue.push({ text: s, lang: ttsLangCode || "" });
  processTTSQueue().catch(()=>{});
}

/* =========================================================
   ✅ Send lang to backend (Fix: previously ignored)
========================================================= */
async function orbitBytes(transcript, ttsLangCode) {
  const res = await fetch(ORBIT_TTS_CFG.endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      text: transcript,
      provider: ORBIT_TTS_CFG.provider,
      lang: ttsLangCode || null,          // ✅ backend can use this if supported
      tts_lang: ttsLangCode || null       // ✅ duplicate key for compatibility
    })
  });

  if (!res.ok) {
    const txt = await res.text().catch(()=> "");
    throw new Error(`Orbit TTS HTTP ${res.status}: ${txt || res.statusText}`);
  }

  return await res.blob();
}

// Play Blob and Return Success/Fail
async function setAndPlayBlob(blob) {
  return new Promise((resolve) => {
    revokeCurrentTtsUrl(); // ✅ prevent object URL leak on rapid calls
    const url = URL.createObjectURL(blob);
    currentTtsObjectUrl = url;

    let done = false;

    ensureOutputAnalyser();
    if (outputCtx && outputCtx.state === "suspended") {
      outputCtx.resume().catch(() => {});
    }

    const cleanup = () => {
      ttsAudio.removeEventListener("error", onErr);
      ttsAudio.removeEventListener("canplaythrough", onCanPlay);
    };

    const onErr = () => {
      if (done) return;
      done = true;
      cleanup();
      revokeCurrentTtsUrl(); // ✅ cleanup on error
      resolve(false);
    };

    const onCanPlay = async () => {
      if (done) return;
      try {
        await ttsAudio.play();
        done = true;
        cleanup();
        resolve(true);
      } catch {
        done = true;
        cleanup();
        revokeCurrentTtsUrl(); // ✅ cleanup if play rejected
        resolve(false);
      }
    };

    ttsAudio.addEventListener("error", onErr, { once: true });
    ttsAudio.addEventListener("canplaythrough", onCanPlay, { once: true });
    ttsAudio.src = url;

    setTimeout(() => {
      if (done) return;
      done = true;
      cleanup();
      resolve(ttsAudio.readyState >= 2);
    }, 2000);
  });
}

// Wait for the 'ended' event
function waitForEnded() {
  return new Promise(resolve => {
    const onEnd = () => {
      revokeCurrentTtsUrl(); // ✅ release object URL after playback
      resolve();
    };
    ttsAudio.addEventListener("ended", onEnd, { once: true });

    setTimeout(() => {
      // fallback resolve if ended doesn't fire
      revokeCurrentTtsUrl();
      resolve();
    }, (isFinite(ttsAudio.duration) ? (ttsAudio.duration * 1000 + 1000) : 2000));
  });
}

// Main Play Function (sequential + retries)
async function speakText(text, ttsLangCode) {
  duckOtherMedia();
  try {
    const blob = await orbitBytes(text, ttsLangCode);
    const ok = await setAndPlayBlob(blob);
    if (!ok) throw new Error("Audio decode failed.");
    await waitForEnded();
  } finally {
    restoreOtherMedia();
  }
}

/*
   ✅ STRICT QUEUE PROCESSOR
*/
async function processTTSQueue() {
  if (ttsBusy) return;
  ttsBusy = true;

  while (ttsQueue.length > 0) {
    const next = ttsQueue.shift();
    try {
      setStatus("Speaking…", "on");
      await speakText(next.text, next.lang);
      await new Promise(r => setTimeout(r, 500));
    } catch (e) {
      ui.debug.textContent = "TTS Err: " + String(e?.message || e);
      await new Promise(r => setTimeout(r, 500));
    }
  }

  ttsBusy = false;
  setStatus(listening ? "Listening…" : "Idle", listening ? "on" : "idle");
}

/* =========================================================
   3. WebSpeech STT & Google Translate
========================================================= */
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognizer = null;
let listening = false;

const ui = {
  root: document.getElementById("orbitRoot"),
  overlay: document.getElementById("overlay"),
  bigText: document.getElementById("bigText"),
  status: document.getElementById("status"),
  debug: document.getElementById("debug"),
  dot: document.getElementById("dot"),
  toggleListenBtn: document.getElementById("toggleListenBtn"),
  translatingLabel: document.getElementById("translatingLabel"),
  srcLang: document.getElementById("srcLang"),
  tgtLang: document.getElementById("tgtLang"),
  fsBtn: document.getElementById("fsBtn"),
  closeBtn: document.getElementById("closeBtn"),
  chevBtn: document.getElementById("chevBtn"),
  orb: document.getElementById("orb"),
  orbitSidebarBtn: document.getElementById("orbitSidebarBtn")
};

function setStatus(text, mode="idle") {
  ui.status.textContent = text;
  ui.dot.classList.remove("on", "err");
  if (mode === "on") ui.dot.classList.add("on");
  if (mode === "err") ui.dot.classList.add("err");
}

/* =========================================================
   ✅ Hard stop (Fix: closing/hiding could leave TTS running)
========================================================= */
function stopAllTTS() {
  try { ttsQueue = []; } catch(_) {}
  try { ttsBusy = false; } catch(_) {}

  try { ttsAudio.pause(); } catch(_) {}
  try { ttsAudio.currentTime = 0; } catch(_) {}

  // Release URL + reset element
  revokeCurrentTtsUrl();
  try { ttsAudio.removeAttribute("src"); } catch(_) {}
  try { ttsAudio.load(); } catch(_) {}

  forceRestoreOtherMedia();
}

function stopEverything() {
  listening = false;

  try { recognizer && recognizer.stop(); } catch(_) {}
  stopInputAnalyser();
  stopAllTTS();

  setStatus("Idle");
  ui.translatingLabel.textContent = "Translating";
}

function setOverlayVisible(isVisible) {
  if (!ui.overlay) return;
  ui.overlay.hidden = !isVisible;

  // ✅ If user hides the overlay, stop audio + listening (recommendation)
  if (!isVisible) {
    stopEverything();
  }
}

function toggleOverlayVisible() {
  if (!ui.overlay) return;
  if (ui.overlay.hidden) setOverlayVisible(true);
  else setOverlayVisible(false);
}

const orbViz = {
  inBars: Array.from(document.querySelectorAll('[data-viz="in"] .orbBar')),
  outBars: Array.from(document.querySelectorAll('[data-viz="out"] .orbBar'))
};

let inputCtx = null;
let inputAnalyser = null;
let inputData = null;
let inputStream = null;
let outputCtx = null;
let outputAnalyser = null;
let outputData = null;
let outputSource = null;
let orbVizRAF = null;

function ensureOutputAnalyser() {
  if (outputCtx || !ttsAudio) return;
  try {
    const AC = window.AudioContext || window.webkitAudioContext;
    outputCtx = new AC();
    outputAnalyser = outputCtx.createAnalyser();
    outputAnalyser.fftSize = 128;
    outputData = new Uint8Array(outputAnalyser.fftSize);
    outputSource = outputCtx.createMediaElementSource(ttsAudio);
    outputSource.connect(outputAnalyser);
    outputAnalyser.connect(outputCtx.destination);
  } catch (_) {}
}

async function ensureInputAnalyser() {
  if (inputCtx) return;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    inputStream = stream;
    const AC = window.AudioContext || window.webkitAudioContext;
    inputCtx = new AC();
    inputAnalyser = inputCtx.createAnalyser();
    inputAnalyser.fftSize = 128;
    inputData = new Uint8Array(inputAnalyser.fftSize);
    const source = inputCtx.createMediaStreamSource(stream);
    source.connect(inputAnalyser);
  } catch (_) {}
}

function stopInputAnalyser() {
  if (inputStream) {
    inputStream.getTracks().forEach((t) => t.stop());
  }
  inputStream = null;
  inputAnalyser = null;
  inputData = null;
  if (inputCtx) {
    inputCtx.close().catch(() => {});
  }
  inputCtx = null;
}

function getLevel(analyser, data) {
  if (!analyser || !data) return 0;
  analyser.getByteTimeDomainData(data);
  let sum = 0;
  for (let i = 0; i < data.length; i++) {
    const v = (data[i] - 128) / 128;
    sum += v * v;
  }
  const rms = Math.sqrt(sum / data.length);
  return Math.min(1, rms * 2.2);
}

function renderBars(bars, level) {
  if (!bars || bars.length === 0) return;
  const count = bars.length;
  for (let i = 0; i < count; i++) {
    const factor = (i + 1) / count;
    const jitter = Math.random() * 2;
    const h = 4 + (level * 18 * factor) + jitter;
    bars[i].style.height = `${Math.round(h)}px`;
  }
}

function startOrbVisualizer() {
  if (orbVizRAF) return;
  const loop = () => {
    const inLevel = getLevel(inputAnalyser, inputData);
    const outLevel = getLevel(outputAnalyser, outputData);
    renderBars(orbViz.inBars, inLevel);
    renderBars(orbViz.outBars, outLevel);
    orbVizRAF = requestAnimationFrame(loop);
  };
  loop();
}

function ensureRecognizer() {
  if (!SpeechRecognition) {
    setStatus("WebSpeech not supported.", "err");
    ui.bigText.textContent = "Browser does not support WebSpeech STT.";
    return false;
  }

  if (!recognizer) {
    recognizer = new SpeechRecognition();
    recognizer.continuous = true;
    recognizer.interimResults = true;

    recognizer.onstart = () => {
      setStatus("Listening…", "on");
      ui.translatingLabel.textContent = "Translating";
    };

    recognizer.onend = () => {
      if (listening) {
        setStatus("Restarting…", "on");
        try { recognizer.start(); } catch(_) {}
      } else {
        setStatus("Idle");
      }
    };

    recognizer.onerror = (e) => {
      setStatus("Mic error: " + (e.error || "unknown"), "err");
      listening = false;
      try { recognizer.stop(); } catch(_) {}
    };

    recognizer.onresult = onSpeechResult;
  }
  return true;
}

/* =========================================================
   4. Text Buffers & Translation
========================================================= */
let finalText = "";
let interimText = "";
let lastTranslatedKey = "";
let translateTimer = null;

let segChain = Promise.resolve();

function currentFullText() {
  return normalizeSpaces((finalText + " " + interimText).trim());
}

function baseLang(code) {
  if (!code) return "";
  const c = String(code).trim().replace(/_/g, "-");
  return c.split("-")[0];
}

async function googleTranslateRaw(text, sl, tl) {
  const q = encodeURIComponent(text);
  const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${encodeURIComponent(sl)}&tl=${encodeURIComponent(tl)}&dt=t&q=${q}`;
  const res = await fetch(url, { method: "GET" });
  if (!res.ok) throw new Error("Translate HTTP " + res.status);
  const data = await res.json();
  const chunks = (data && data[0]) ? data[0] : [];
  return chunks.map(x => x && x[0] ? x[0] : "").join("").trim();
}

async function googleTranslate(text, sl, tl) {
  const sl1 = (sl || "").trim();
  const tl1 = (tl || "").trim();
  const sl2 = baseLang(sl1);
  const tl2 = baseLang(tl1);

  try { return await googleTranslateRaw(text, sl1, tl1); } catch (_) {}

  if (sl2 && sl2 !== sl1) {
    try { return await googleTranslateRaw(text, sl2, tl1); } catch (_) {}
  }
  if (tl2 && tl2 !== tl1) {
    try { return await googleTranslateRaw(text, sl1, tl2); } catch (_) {}
  }
  if (sl2 && tl2 && (sl2 !== sl1 || tl2 !== tl1)) {
    return await googleTranslateRaw(text, sl2, tl2);
  }

  return await googleTranslateRaw(text, sl1, tl1);
}

function scheduleTranslateNow(force=false) {
  if (translateTimer) clearTimeout(translateTimer);
  translateTimer = setTimeout(async () => {
    const sl = getLangMeta(ui.srcLang).translate;
    const tl = getLangMeta(ui.tgtLang).translate;
    const full = currentFullText();
    if (!full) return;

    const clipped = full.length > 520 ? full.slice(-520) : full;
    const key = `${sl}|${tl}|${clipped}`;
    if (!force && key === lastTranslatedKey) return;
    lastTranslatedKey = key;

    try {
      setStatus("Translating…", "on");
      const translated = await googleTranslate(clipped, sl, tl);
      ui.bigText.textContent = translated || "…";
      setStatus(listening ? "Listening…" : "Idle", listening ? "on" : "idle");
    } catch (err) {
      setStatus("Translate error.", "err");
    }
  }, force ? 0 : 100);
}

async function translateAndSpeakSegment(finalSegment, sl, tl, ttsLang) {
  const seg = normalizeSpaces(finalSegment);
  if (!seg) return;
  try {
    const translatedSeg = await googleTranslate(seg, sl, tl);
    if (translatedSeg) enqueueTTS(translatedSeg, ttsLang);
  } catch (e) {
    ui.debug.textContent = "Seg Trans Err: " + String(e?.message || e);
  }
}

function onSpeechResult(event) {
  let interim = "";
  for (let i = event.resultIndex; i < event.results.length; i++) {
    const r = event.results[i];
    const t = r[0]?.transcript || "";
    if (r.isFinal) {
      const cleaned = normalizeSpaces(t);
      if (cleaned) {
        finalText = normalizeSpaces(finalText + " " + cleaned);

        const src = getLangMeta(ui.srcLang);
        const tgt = getLangMeta(ui.tgtLang);

        segChain = segChain
          .then(() => translateAndSpeakSegment(cleaned, src.translate, tgt.translate, tgt.cartesia))
          .catch(() => {});
      }
    } else {
      interim += t;
    }
  }
  interimText = normalizeSpaces(interim);
  const full = currentFullText();
  ui.debug.textContent = full ? `Heard: ${full.slice(-90)}` : "";
  scheduleTranslateNow(false);
}

/* =========================================================
   5. Controls & Events
========================================================= */
async function startListening() {
  if (!ensureRecognizer()) return;
  if (listening) return;

  // Ensure UI visible
  ui.overlay.hidden = false;

  await unlockAudioOnce();
  await ensureInputAnalyser();

  finalText = "";
  interimText = "";
  lastTranslatedKey = "";
  ui.bigText.textContent = "Listening…";
  setStatus("Requesting mic…", "on");

  const src = getLangMeta(ui.srcLang);
  recognizer.lang = src.speech;

  listening = true;
  try {
    recognizer.start();
  } catch (e) {
    try { recognizer.stop(); } catch(_) {}
    setTimeout(() => {
      try { recognizer.start(); } catch(err) {
        setStatus("Mic fail", "err");
        listening = false;
      }
    }, 250);
  }
}

function stopListening() {
  listening = false;
  stopInputAnalyser();
  try { recognizer && recognizer.stop(); } catch(_) {}
  setStatus("Idle");
}

ui.toggleListenBtn.addEventListener("click", () => {
  if (listening) stopListening();
  else startListening();
});

ui.srcLang.addEventListener("change", () => {
  if (recognizer) recognizer.lang = getLangMeta(ui.srcLang).speech;
  scheduleTranslateNow(true);
});

ui.tgtLang.addEventListener("change", () => scheduleTranslateNow(true));

ui.closeBtn.addEventListener("click", () => {
  // ✅ Close = hard stop + hide
  stopEverything();
  setOverlayVisible(false);
});

ui.chevBtn.addEventListener("click", () => ui.overlay.classList.toggle("collapsed"));

ui.fsBtn.addEventListener("click", async () => {
  try { document.fullscreenElement ? document.exitFullscreen() : ui.overlay.requestFullscreen(); } catch(_){}
});

if (ui.orbitSidebarBtn) {
  ui.orbitSidebarBtn.addEventListener("click", () => {
    toggleOverlayVisible();
  });
}

/* =========================================================
   ✅ Orb drag within root bounds (Fix: was using window bounds)
========================================================= */
if (ui.orb && ui.root) {
  let orbDragging = false;
  let orbMoved = false;
  let startX = 0;
  let startY = 0;
  let startLeft = 0;
  let startTop = 0;

  const getRootRect = () => ui.root.getBoundingClientRect();

  const setOrbPosition = (left, top) => {
    const size = ui.orb.offsetWidth || 75;
    const rootRect = getRootRect();
    const maxLeft = Math.max(0, rootRect.width - size);
    const maxTop  = Math.max(0, rootRect.height - size);
    const nextLeft = Math.max(0, Math.min(left, maxLeft));
    const nextTop  = Math.max(0, Math.min(top, maxTop));
    ui.orb.style.right = "auto";
    ui.orb.style.bottom = "auto";
    ui.orb.style.left = `${nextLeft}px`;
    ui.orb.style.top  = `${nextTop}px`;
  };

  const clampOrbToRoot = () => {
    const rootRect = getRootRect();
    const rect = ui.orb.getBoundingClientRect();
    const relLeft = rect.left - rootRect.left;
    const relTop  = rect.top  - rootRect.top;
    setOrbPosition(relLeft, relTop);
  };

  ui.orb.addEventListener("pointerdown", (e) => {
    if (e.button && e.button !== 0) return;

    const rootRect = getRootRect();
    const rect = ui.orb.getBoundingClientRect();

    startLeft = rect.left - rootRect.left;
    startTop  = rect.top  - rootRect.top;
    startX = e.clientX;
    startY = e.clientY;

    orbDragging = true;
    orbMoved = false;
    ui.orb.classList.add("dragging");
    ui.orb.setPointerCapture(e.pointerId);
  });

  ui.orb.addEventListener("pointermove", (e) => {
    if (!orbDragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) orbMoved = true;
    setOrbPosition(startLeft + dx, startTop + dy);
  });

  const stopDrag = (e) => {
    if (!orbDragging) return;
    orbDragging = false;
    ui.orb.classList.remove("dragging");
    try { ui.orb.releasePointerCapture(e.pointerId); } catch(_) {}

    if (!orbMoved) {
      toggleOverlayVisible();
    }
  };

  ui.orb.addEventListener("pointerup", stopDrag);
  ui.orb.addEventListener("pointercancel", stopDrag);

  ui.orb.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      toggleOverlayVisible();
    }
  });

  clampOrbToRoot();

  window.addEventListener("resize", clampOrbToRoot);
  if (window.ResizeObserver) {
    const ro = new ResizeObserver(() => clampOrbToRoot());
    ro.observe(ui.root);
  }
}

/* =========================================================
   6. FULL Language + Dialect + Regional List (No Skips)
========================================================= */
const VARIANTS = [
  ["en-US","English (United States)","en-US","en-US","en"],
  ["en-GB","English (United Kingdom)","en-GB","en-GB","en"],
  ["en-AU","English (Australia)","en-AU","en-AU","en"],
  ["en-CA","English (Canada)","en-CA","en-CA","en"],
  ["en-NZ","English (New Zealand)","en-NZ","en-NZ","en"],
  ["en-PH","English (Philippines)","en-PH","en-PH","en"],
  ["en-ZA","English (South Africa)","en-ZA","en-ZA","en"],
  ["en-IN","English (India)","en-IN","en-IN","en"],

  ["nl-NL","Dutch (Netherlands)","nl","nl-NL","nl"],
  ["nl-BE","Dutch (Belgium / Flemish)","nl-BE","nl-BE","nl"],

  ["fr-FR","French (France)","fr-FR","fr-FR","fr"],
  ["fr-CA","French (Canada)","fr-CA","fr-CA","fr"],
  ["fr-CH","French (Switzerland)","fr-CH","fr-CH","fr"],

  ["es-ES","Spanish (Spain)","es-ES","es-ES","es"],
  ["es-MX","Spanish (Mexico)","es-MX","es-MX","es"],
  ["es-US","Spanish (United States)","es-US","es-US","es"],
  ["es-419","Spanish (Latin America)","es-419","es-419","es"],
  ["es-AR","Spanish (Argentina)","es-AR","es-AR","es"],
  ["es-CL","Spanish (Chile)","es-CL","es-CL","es"],
  ["es-CO","Spanish (Colombia)","es-CO","es-CO","es"],
  ["es-PE","Spanish (Peru)","es-PE","es-PE","es"],
  ["es-VE","Spanish (Venezuela)","es-VE","es-VE","es"],
  ["es-UY","Spanish (Uruguay)","es-UY","es-UY","es"],
  ["es-EC","Spanish (Ecuador)","es-EC","es-EC","es"],
  ["es-GT","Spanish (Guatemala)","es-GT","es-GT","es"],
  ["es-HN","Spanish (Honduras)","es-HN","es-HN","es"],
  ["es-NI","Spanish (Nicaragua)","es-NI","es-NI","es"],
  ["es-PA","Spanish (Panama)","es-PA","es-PA","es"],
  ["es-PY","Spanish (Paraguay)","es-PY","es-PY","es"],
  ["es-PR","Spanish (Puerto Rico)","es-PR","es-PR","es"],
  ["es-CR","Spanish (Costa Rica)","es-CR","es-CR","es"],
  ["es-SV","Spanish (El Salvador)","es-SV","es-SV","es"],
  ["es-HT","Spanish (Haiti)","es-HT","es-HT","es"],

  ["pt-PT","Portuguese (Portugal)","pt-PT","pt-PT","pt"],
  ["pt-BR","Portuguese (Brazil)","pt-BR","pt-BR","pt"],

  ["zh-CN","Chinese (China / Simplified)","zh-CN","zh-CN","zh"],
  ["zh-TW","Chinese (Taiwan / Traditional)","zh-TW","zh-TW","zh"],
  ["zh-HK","Chinese (Hong Kong)","zh-HK","zh-HK","zh"],
  ["zh-Hans","Chinese (Simplified Script)","zh-Hans","zh-Hans","zh"],
  ["zh-Hant","Chinese (Traditional Script)","zh-Hant","zh-Hant","zh"],

  ["ar-SA","Arabic (Saudi Arabia)","ar-SA","ar-SA","ar"],

  ["bn-IN","Bengali (India)","bn-IN","bn-IN","bn"],
  ["pa-PK","Punjabi (Pakistan)","pa-PK","pa-PK","pa"],

  ["bs-Cyrl","Bosnian (Cyrillic)","bs-Cyrl","bs-Cyrl",""],
  ["ms-Arab","Malay (Jawi)","ms-Arab","ms-Arab","ms"],
  ["pa-Arab","Punjabi (Shahmukhi)","pa-Arab","pa-Arab","pa"],
  ["mni-Mtei","Meiteilon (Manipuri, Meitei Mayek)","mni-Mtei","mni-Mtei",""],
  ["nb-NO","Norwegian Bokmål (Norway)","nb","nb-NO","no"]
];

const BASE_LANGS = {
  "ab":"Abkhaz","ace":"Acehnese","ach":"Acholi","af":"Afrikaans","sq":"Albanian","alz":"Alur","am":"Amharic","ar":"Arabic",
  "hy":"Armenian","as":"Assamese","awa":"Awadhi","ay":"Aymara","az":"Azerbaijani","ban":"Balinese","bm":"Bambara","ba":"Bashkir",
  "eu":"Basque","btx":"Batak Karo","bts":"Batak Simalungun","bbc":"Batak Toba","be":"Belarusian","bem":"Bemba","bn":"Bengali",
  "bew":"Betawi","bho":"Bhojpuri","bik":"Bikol","bs":"Bosnian","br":"Breton","bg":"Bulgarian","bua":"Buryat","yue":"Cantonese",
  "ca":"Catalan","ceb":"Cebuano","ny":"Chichewa (Nyanja)","zh":"Chinese","zh-CN":"Chinese (Simplified)","zh-TW":"Chinese (Traditional)",
  "cv":"Chuvash","co":"Corsican","crh":"Crimean Tatar","hr":"Croatian","cs":"Czech","da":"Danish","din":"Dinka","dv":"Divehi",
  "doi":"Dogri","dov":"Dombe","nl":"Dutch","dz":"Dzongkha","en":"English","eo":"Esperanto","et":"Estonian","ee":"Ewe","fj":"Fijian",
  "fil":"Filipino","tl":"Tagalog","fi":"Finnish","fr":"French","fy":"Frisian","ff":"Fulfulde","gaa":"Ga","gl":"Galician",
  "lg":"Ganda (Luganda)","ka":"Georgian","de":"German","el":"Greek","gn":"Guarani","gu":"Gujarati","ht":"Haitian Creole",
  "cnh":"Hakha Chin","ha":"Hausa","haw":"Hawaiian","he":"Hebrew","iw":"Hebrew (legacy iw)","hil":"Hiligaynon","hi":"Hindi","hmn":"Hmong",
  "hu":"Hungarian","hrx":"Hunsrik","is":"Icelandic","ig":"Igbo","ilo":"Iloko","id":"Indonesian","ga":"Irish","it":"Italian","ja":"Japanese",
  "jw":"Javanese (jw)","jv":"Javanese (jv)","kn":"Kannada","pam":"Kapampangan","kk":"Kazakh","km":"Khmer","cgg":"Kiga","rw":"Kinyarwanda",
  "ktu":"Kituba","gom":"Konkani","ko":"Korean","kri":"Krio","ku":"Kurdish (Kurmanji)","ckb":"Kurdish (Sorani)","ky":"Kyrgyz","lo":"Lao",
  "ltg":"Latgalian","la":"Latin","lv":"Latvian","lij":"Ligurian","li":"Limburgan","ln":"Lingala","lt":"Lithuanian","lmo":"Lombard","luo":"Luo",
  "lb":"Luxembourgish","mk":"Macedonian","mai":"Maithili","mak":"Makassar","mg":"Malagasy","ms":"Malay","ml":"Malayalam","mt":"Maltese",
  "mi":"Maori","mr":"Marathi","chm":"Meadow Mari","min":"Minang","lus":"Mizo","mn":"Mongolian","my":"Myanmar (Burmese)","nr":"Ndebele (South)",
  "new":"Nepalbhasa (Newari)","ne":"Nepali","nso":"Northern Sotho (Sepedi)","no":"Norwegian","nus":"Nuer","oc":"Occitan","or":"Odia (Oriya)",
  "om":"Oromo","pag":"Pangasinan","pap":"Papiamento","ps":"Pashto","fa":"Persian","pl":"Polish","pt":"Portuguese","pa":"Punjabi","qu":"Quechua",
  "rom":"Romani","ro":"Romanian","rn":"Rundi","ru":"Russian","sm":"Samoan","sg":"Sango","sa":"Sanskrit","gd":"Scots Gaelic","sr":"Serbian",
  "st":"Sesotho","crs":"Seychellois Creole","shn":"Shan","sn":"Shona","scn":"Sicilian","szl":"Silesian","sd":"Sindhi","si":"Sinhala (Sinhalese)",
  "sk":"Slovak","sl":"Slovenian","so":"Somali","es":"Spanish","su":"Sundanese","sw":"Swahili","ss":"Swati","sv":"Swedish","tg":"Tajik","ta":"Tamil",
  "tt":"Tatar","te":"Telugu","tet":"Tetum","th":"Thai","ti":"Tigrinya","ts":"Tsonga","tn":"Tswana","tr":"Turkish","tk":"Turkmen","ak":"Twi (Akan)",
  "uk":"Ukrainian","ur":"Urdu","ug":"Uyghur","uz":"Uzbek","vi":"Vietnamese","cy":"Welsh","xh":"Xhosa","yi":"Yiddish","yo":"Yoruba","yua":"Yucatec Maya","zu":"Zulu"
};

function defaultSpeechForTranslate(code) {
  const c = String(code || "").trim().replace(/_/g,"-");
  const b = baseLang(c);

  if (c === "fil" || c === "tl") return "fil-PH";
  if (b === "en") return c.includes("-") ? c : "en-US";
  if (b === "fr") return c.includes("-") ? c : "fr-FR";
  if (b === "nl") return c.includes("-") ? c : "nl-NL";
  if (b === "de") return c.includes("-") ? c : "de-DE";
  if (b === "es") return c.includes("-") ? c : "es-ES";
  if (b === "pt") return c.includes("-") ? c : "pt-PT";
  if (b === "zh") return c.includes("-") ? c : "zh-CN";
  if (b === "ar") return c.includes("-") ? c : "ar-SA";
  if (b === "he") return "he-IL";
  if (b === "iw") return "he-IL";
  return c || "en-US";
}

function defaultCartesiaForTranslate(code) {
  const b = baseLang(code);
  return CARTESIA_LANGS.has(b) ? b : "";
}

function escapeHtml(s) {
  return String(s ?? "")
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;")
    .replace(/'/g,"&#39;");
}

function populateLangs() {
  const opts = [];

  for (const [id,label,translate,speech,cartesia] of VARIANTS) {
    opts.push(
      `<option value="${escapeHtml(id)}" data-translate="${escapeHtml(translate)}" data-speech="${escapeHtml(speech)}" data-cartesia="${escapeHtml(cartesia || "")}">${escapeHtml(label)}</option>`
    );
  }

  const basePairs = Object.entries(BASE_LANGS).sort((a,b) => a[1].localeCompare(b[1]));
  for (const [code, name] of basePairs) {
    if (!code) continue;
    const translate = code;
    const speech = defaultSpeechForTranslate(code);
    const cartesia = defaultCartesiaForTranslate(code);
    opts.push(
      `<option value="${escapeHtml(code)}" data-translate="${escapeHtml(translate)}" data-speech="${escapeHtml(speech)}" data-cartesia="${escapeHtml(cartesia)}">${escapeHtml(name)} (${escapeHtml(code)})</option>`
    );
  }

  ui.srcLang.innerHTML = opts.join("");
  ui.tgtLang.innerHTML = opts.join("");

  ui.srcLang.value = "en-US";
  ui.tgtLang.value = "nl-BE";
}

function getLangMeta(selectEl) {
  const opt = selectEl.selectedOptions && selectEl.selectedOptions[0];
  const value = selectEl.value || "en-US";

  const translate = (opt && opt.dataset && opt.dataset.translate) ? opt.dataset.translate : value;
  const speech = (opt && opt.dataset && opt.dataset.speech) ? opt.dataset.speech : defaultSpeechForTranslate(value);
  const cartesia = (opt && opt.dataset && opt.dataset.cartesia) ? opt.dataset.cartesia : defaultCartesiaForTranslate(value);

  return { value, translate, speech, cartesia };
}

populateLangs();
setStatus("Idle");
startOrbVisualizer();
</script>
</body>
</html>
